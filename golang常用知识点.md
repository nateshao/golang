[TOC]

# 数组与切片

## 数组与切片的异同

1. **定义**：
   - **数组**：长度固定，不可改变。
   - **切片**：长度可变，动态增长。
- **初始化**：
   - **数组**：使用 `var` 或 `:=` 初始化。
   - **切片**：使用 `make` 或 `[]` 初始化。

```go
// runtime/code1_slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
```


## 切片的容量是怎样增长的

1. **容量不足时触发扩容**：当使用 `append` 向切片添加元素时，如果容量不足，切片会自动扩容。
2. **扩容策略**：
   - **容量小于 1024**：容量每次翻倍（即 `cap = cap * 2`）。
   - **容量大于等于 1024**：容量每次增加约 25%（即 `cap = cap + cap / 4`）。
3. **底层实现**：扩容时会分配新的底层数组，将原数组的元素复制到新数组中，可能引发内存重新分配。

#### **注意**

- 手动初始化容量时，扩容频率和内存开销可优化。
- 切片容量增长并不改变原始切片的内容，只更新新的切片指向的底层数组。



## 切片作为函数参数

Go 语言的函数参数传递，只有值传递，没有引用传递。

# 哈希表

## map 的实现原理

Go 语言中的 `map` 是基于哈希表实现的：

1. **底层数据结构：哈希表**
    `map` 使用哈希表存储键值对，每个桶存储多个键值对。

2. **哈希函数**
    键通过哈希函数映射到哈希表中的桶，哈希值决定元素存放的位置。

3. **哈希冲突解决**
    使用开放寻址法解决哈希冲突，冲突的键值对存储在同一桶中的链表或数组中。

   **开放寻址法**：当多个键的哈希值相同，即发生哈希冲突时，Go 使用开放寻址法来解决冲突。

   当冲突发生时，Go 会将冲突的元素存储到相同桶中的链表或者数组中，这称为“桶扩展”。

   在高并发的情况下，Go 还会使用更高效的方式来处理冲突。

4. **动态扩容**
    当负载因子超过阈值时，`map` 会扩展桶的数量并重新分配已有元素。

5. **操作复杂度**
    查找、插入和删除操作的平均时间复杂度为 **O(1)**，但在冲突较多时可能退化到 **O(n)**。

6. **并发安全**
    默认情况下，`map` 不是并发安全的，必须使用锁（如 `sync.Mutex`）来保护并发访问。

## 如何实现两种 get 操作

## 遍历过程

## 赋值过程

## 删除过程

## 扩容过程

## key 为什么是无序的

底层使用了哈希表（Hash Table）来存储数据。哈希表通过哈希函数将键映射到一个特定的位置，键值对在哈希表中的存储顺序没有固定规律。

## float 类型可以作为 map 的 key 吗

在 Go 语言中，`float` 类型**不能作为 `map` 的 key**。这是因为 `float` 类型存在精度问题，可能导致不同的 `float` 值看似相等但实际上不完全相同，这会破坏哈希表的正确性和一致性。Go 的 `map` 键需要是可比较的类型（例如，整数、字符串、指针、结构体等），而浮点数由于其表示方式不精确，因此不能用作 `map` 的键。



## 可以边遍历边删除吗

一般而言，这可以通过读写锁来解决：`sync.RWMutex`。

读之前调用 `RLock()` 函数，读完之后调用 `RUnlock()` 函数解锁；写之前调用 `Lock()` 函数，写完之后，调用 `Unlock()` 解锁。

另外，`sync.Map` 是线程安全的 map，也可以使用。

## 可以对 map 的元素取地址吗

无法对 map 的 key 或 value 进行取

## 如何比较两个 map 相等

在 Go 中，直接使用 `==` 比较两个 `map` 是否相等是不可行的，因为 `map` 是引用类型，没有定义 `==` 运算符。因此，比较两个 `map` 是否相等需要逐一比较它们的键和值。具体方法如下：

1. **键数量比较**：首先检查两个 `map` 的键数量是否相同。
2. **逐个键值对比较**：对于每个键，检查其在两个 `map` 中的值是否相同。

示例代码：

```go
func mapsEqual(map1, map2 map[string]int) bool {
    if len(map1) != len(map2) {
        return false
    }
    for k, v1 := range map1 {
        if v2, ok := map2[k]; !ok || v1 != v2 {
            return false
        }
    }
    return true
}
```

总结：两个 `map` 相等的条件是它们具有相同的键和值且顺序无关。

## map 是线程安全的吗

Go 中的 `map` **不是线程安全**的。

在并发环境下，如果多个 goroutine 同时对同一个 `map` 进行读写操作，会导致数据竞争和未定义的行为，甚至可能导致程序崩溃。因此，在并发操作 `map` 时，需要使用同步机制来保证线程安全。

解决方案：

1. 使用 **`sync.Mutex`** 或 **`sync.RWMutex`** 来显式加锁，确保在同一时刻只有一个 goroutine 可以对 `map` 进行写操作。
2. 使用 **`sync.Map`**，这是 Go 标准库中提供的线程安全的 `map` 实现，专门设计用于并发读写。

示例使用 `sync.Mutex`：

```go
import "sync"

var mu sync.Mutex
var m = make(map[string]int)

func safeWrite(key string, value int) {
    mu.Lock()
    m[key] = value
    mu.Unlock()
}

func safeRead(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}
```

总结：默认的 `map` 不是线程安全的，需要使用同步机制来确保在并发环境下的安全操作。

# 接口



## Go 语言与鸭子类型的关系



## 值接收者和指针接收者的区别



## iface 和 eface 的区别是什么



## 接口的动态类型和动态值



## 编译器自动检测类型是否实现接口



## 接口的构造过程是怎样的



## 类型转换和断言的区别



## 接口转换的原理



## 如何用 interface 实现多态



## Go 接口与 C++ 接口有何异同



# 通道



## 什么是 CSP



## channel 底层的数据结构是什么



## 向 channel 发送数据的过程是怎样的



## 从 channel 接收数据的过程是怎样的



## 关闭一个 channel 的过程是怎样的



## 从一个关闭的 channel 仍然能读出数据吗



## 操作 channel 的情况总结



## 如何优雅地关闭 channel



## channel 发送和接收元素的本质是什么



## channel 在什么情况下会引起资源泄漏



## 关于 channel 的 happened-before 有哪些



## channel 有哪些应用



# 标准库

# context
  ## context 是什么
`context` 是 Go 语言中的一个包，提供了一种在多个 goroutine 之间传递元数据和控制信号的方式。它的主要作用是用于处理超时、取消操作和跨 goroutine 传递值。

简要概括：
1. **用于跨 API 边界传递信息**：在处理 HTTP 请求、数据库查询等操作时，`context` 可以传递一些请求级别的信息，比如请求的超时时间、取消信号等。
2. **用于控制 goroutine 的生命周期**：`context` 可以用来控制 goroutine 的执行，支持取消（`Cancel`）信号或超时（`Timeout`）。
3. **避免资源泄漏**：在一些长时间运行的操作中，`context` 可以帮助取消那些不再需要的操作，从而避免资源泄漏。
4. **可用于传递请求范围的值**：例如，可以将用户身份、请求 ID 等信息保存在 `context` 中，并在多个 goroutine 之间共享。

常见操作：
- `context.Background()`：创建一个空的 context，通常作为根上下文。
- `context.WithCancel()`：创建一个可以取消的 context。
- `context.WithTimeout()`：创建一个具有超时限制的 context。
- `context.WithValue()`：将数据（如请求 ID）保存在 context 中，以便在不同的 goroutine 中访问。

`context` 的核心作用是帮助协作管理并发操作，特别是在需要取消任务或设定超时的场景中。


  ## context 有什么作用
  ## context.Value 的查找过程是怎样的
  ## context 如何被取消
# reflect▾
  ## 什么是反射
  ## 什么情况下需要使用反射
  ## Go 语言如何实现反射
  ## Go 语言中反射有哪些应用
  ## 如何比较两个对象完全相同
# unsafe▾
  ## Go指针和unsafe.Pointer有什么区别
  ## 如何利用unsafe获取slice&map的长度
  ## 如何利用unsafe包修改私有成员
  ## 如何实现字符串和byte切片的零拷贝转换


# 编译
## 指针逃逸

通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。

Go语言逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。

## 逃逸分析是怎么进行的

## GoRoot 和 GoPath 有什么用

## Go 编译链接过程概述

## Go 编译相关的命令详解

## Go 程序启动过程是怎样的
Go 程序的启动过程如下：

1. **编译阶段**：
    - **Go 源代码编译**：Go 程序会首先被编译成机器码。使用 `go build` 或 `go run` 命令时，Go 编译器会将 `.go` 源文件编译成目标文件，最后链接成一个可执行文件。
    - **生成二进制文件**：Go 会自动将程序中的依赖和库链接在一起，最终生成一个独立的二进制文件，无需依赖外部运行时。

2. **程序初始化**：
    - **入口函数**：Go 程序的入口函数是 `main` 包中的 `main()` 函数，程序从 `main()` 函数开始执行。
    - **初始化全局变量和包级变量**：在 `main()` 函数执行之前，Go 会初始化所有全局变量和导入包的 `init()` 函数。如果存在多个包级别的 `init()` 函数，它们会按照包的导入顺序执行。

3. **启动运行时**：
    - **Go 运行时初始化**：Go 程序使用 Go 运行时 (runtime)，它负责管理 goroutine 调度、内存分配、垃圾回收等。运行时的初始化包括启动垃圾回收器、设置 goroutine 调度器、设置系统调用等。
    - **启动 goroutines**：Go 程序会启动一个主 goroutine，通常这是执行 `main()` 函数的地方。如果有其他 goroutines（例如并发任务），它们也会启动并进行调度。

4. **执行 `main()` 函数**：
    - **执行程序逻辑**：Go 程序开始执行 `main()` 函数中的业务逻辑。如果在程序中使用了其他 goroutines，这些 goroutines 会并发运行。
    - **等待 goroutines 结束**：主 goroutine 会阻塞，直到所有 goroutines 执行完毕或通过某种机制（如 `sync.WaitGroup`）等待它们的结束。

5. **退出程序**：
    - **垃圾回收与资源清理**：程序退出时，Go 运行时会进行垃圾回收和资源清理，释放堆上的内存和其他资源。
    - **程序终止**：所有的 goroutines 和线程退出后，程序就会终止并返回退出状态。

总结：Go 程序启动过程主要包括编译、初始化、运行时设置、执行 `main()` 函数、并发执行 goroutines，最后终止。

# 调度器▾
##  goroutine 和线程的区别
##  什么是 Go Scheduler
##  goroutine 调度时机有哪些
##  什么是M:N模型
##  什么是工作窃取
##  GPM 是什么
##  描述 scheduler 的初始化过程
##  主 goroutine 如何创建
##  g0 栈何用户栈如何切换
##  schedule 循环如何启动
##  goroutine 如何退出
##  schedule 循环如何运转
##  M 如何找工作
##  sysmon 后台监控线程做了什么
##  一个调度相关的陷阱
# 垃圾回收器▾
## 垃圾回收的认识
## 垃圾回收机制的实现
## 垃圾回收的优化问题